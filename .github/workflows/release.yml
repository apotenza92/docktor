name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (example: v1.0.0 or v1.0.0-beta.1)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}
      version_core: ${{ steps.meta.outputs.version_core }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
      build_number: ${{ steps.meta.outputs.build_number }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse tag metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            CORE_VERSION="$VERSION"
            PRERELEASE="false"
          elif [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)-([0-9A-Za-z.-]+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}"
            CORE_VERSION="${BASH_REMATCH[1]}"
            PRERELEASE="true"
          else
            echo "::error::Tag must match vX.Y.Z or vX.Y.Z-<prerelease>"
            exit 1
          fi

          PROJECT_VERSION="$(python3 -c 'import re, pathlib; text = pathlib.Path("Dockter.xcodeproj/project.pbxproj").read_text(encoding="utf-8"); m = re.search(r"MARKETING_VERSION = ([0-9]+\.[0-9]+\.[0-9]+);", text); print(m.group(1) if m else "")')"

          if [[ "$PROJECT_VERSION" != "$CORE_VERSION" ]]; then
            echo "::error::Tag core version ($CORE_VERSION) must match MARKETING_VERSION ($PROJECT_VERSION)."
            exit 1
          fi

          BUILD_NUMBER="$(python3 -c 'import re,sys; tag=sys.argv[1]; m=re.fullmatch(r"v(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z.-]+))?", tag); assert m; major,minor,patch=int(m.group(1)),int(m.group(2)),int(m.group(3)); prerelease=m.group(4); core=(major*1_000_000)+(minor*1_000)+patch; beta_match=(re.search(r"(?:beta|b)[.-]?(\d+)$", prerelease, flags=re.IGNORECASE) if prerelease else None); stage=(90_000 if prerelease is None else (min(max(int(beta_match.group(1)),1),89_999) if beta_match else 50_000)); print((core*100_000)+stage)' "$TAG")"

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "version_core=$CORE_VERSION" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"
          echo "build_number=$BUILD_NUMBER" >> "$GITHUB_OUTPUT"

      - name: Verify changelog entry exists
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/release_notes_from_changelog.py --tag "${{ steps.meta.outputs.tag }}" > /dev/null

  build-macos:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-15
            arch: arm64
            xcode_arch: arm64
            channel: stable
            product_name: Dockter
            package_prefix: Dockter
            bundle_id: pzc.Dockter
            app_icon: AppIcon
          - runner: macos-15
            arch: x64
            xcode_arch: x86_64
            channel: stable
            product_name: Dockter
            package_prefix: Dockter
            bundle_id: pzc.Dockter
            app_icon: AppIcon
          - runner: macos-15
            arch: arm64
            xcode_arch: arm64
            channel: beta
            product_name: Dockter Beta
            package_prefix: Dockter-Beta
            bundle_id: pzc.Dockter.beta
            app_icon: AppIconBeta
          - runner: macos-15
            arch: x64
            xcode_arch: x86_64
            channel: beta
            product_name: Dockter Beta
            package_prefix: Dockter-Beta
            bundle_id: pzc.Dockter.beta
            app_icon: AppIconBeta
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag }}

      - name: Import signing certificate
        shell: bash
        env:
          APPLE_SIGNING_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_SIGNING_CERTIFICATE_P12_BASE64 }}
          APPLE_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_SIGNING_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_CERTIFICATE_P12_BASE64"
          test -n "$APPLE_SIGNING_CERTIFICATE_PASSWORD"

          CERT_PATH="$RUNNER_TEMP/dockactioner-signing.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/dockactioner.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"

          python3 -c 'import base64, pathlib, sys; pathlib.Path(sys.argv[1]).write_bytes(base64.b64decode(sys.argv[2]))' "$CERT_PATH" "$APPLE_SIGNING_CERTIFICATE_P12_BASE64"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security import "$CERT_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_SIGNING_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Build signed app archive
        shell: bash
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          BUILD_NUMBER: ${{ needs.prepare.outputs.build_number }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_IDENTITY"
          test -n "$APPLE_TEAM_ID"

          ARCHIVE_PATH="$RUNNER_TEMP/${{ matrix.package_prefix }}-${{ matrix.arch }}.xcarchive"
          EXPORT_PATH="$RUNNER_TEMP/export-${{ matrix.package_prefix }}-${{ matrix.arch }}"
          EXPORT_OPTIONS_PATH="$RUNNER_TEMP/export-options-${{ matrix.package_prefix }}-${{ matrix.arch }}.plist"

          xcodebuild \
            -project Dockter.xcodeproj \
            -scheme Dockter \
            -configuration Release \
            -destination "generic/platform=macOS" \
            -archivePath "$ARCHIVE_PATH" \
            archive \
            ARCHS="${{ matrix.xcode_arch }}" \
            ONLY_ACTIVE_ARCH=YES \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$APPLE_SIGNING_IDENTITY" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            MARKETING_VERSION="$VERSION_CORE" \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
            PRODUCT_NAME="${{ matrix.product_name }}" \
            PRODUCT_BUNDLE_IDENTIFIER="${{ matrix.bundle_id }}" \
            ASSETCATALOG_COMPILER_APPICON_NAME="${{ matrix.app_icon }}" \
            OTHER_CODE_SIGN_FLAGS="--timestamp"

          cat > "$EXPORT_OPTIONS_PATH" <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>developer-id</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>${APPLE_SIGNING_IDENTITY}</string>
            <key>teamID</key>
            <string>${APPLE_TEAM_ID}</string>
          </dict>
          </plist>
          EOF

          xcodebuild \
            -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PATH"

          APP_PATH="$EXPORT_PATH/${{ matrix.product_name }}.app"
          if [[ ! -d "$APP_PATH" ]]; then
            echo "::error::Expected app bundle not found at $APP_PATH"
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

          mkdir -p dist
          cp -R "$APP_PATH" "dist/${{ matrix.product_name }}.app"

      - name: Notarize and staple with notarytool
        shell: bash
        env:
          APPLE_NOTARYTOOL_KEY_ID: ${{ secrets.APPLE_NOTARYTOOL_KEY_ID }}
          APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
          APPLE_NOTARYTOOL_KEY_P8_BASE64: ${{ secrets.APPLE_NOTARYTOOL_KEY_P8_BASE64 }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          MODE=""
          if [[ -n "${APPLE_NOTARYTOOL_KEY_ID:-}" && -n "${APPLE_NOTARYTOOL_ISSUER_ID:-}" && -n "${APPLE_NOTARYTOOL_KEY_P8_BASE64:-}" ]]; then
            MODE="api_key"
          elif [[ -n "${APPLE_ID:-}" && -n "${APPLE_APP_SPECIFIC_PASSWORD:-}" && -n "${APPLE_TEAM_ID:-}" ]]; then
            MODE="apple_id"
          else
            echo "::error::Missing notarization credentials. Configure either notarytool API key secrets or APPLE_ID + APPLE_APP_SPECIFIC_PASSWORD + APPLE_TEAM_ID."
            exit 1
          fi

          KEY_PATH=""
          if [[ "$MODE" == "api_key" ]]; then
            KEY_PATH="$RUNNER_TEMP/AuthKey_${APPLE_NOTARYTOOL_KEY_ID}.p8"
            python3 -c 'import base64, pathlib, sys; pathlib.Path(sys.argv[1]).write_bytes(base64.b64decode(sys.argv[2]))' "$KEY_PATH" "$APPLE_NOTARYTOOL_KEY_P8_BASE64"
          fi

          APP_PATH="dist/${{ matrix.product_name }}.app"
          UPLOAD_ZIP="$RUNNER_TEMP/notary-upload.zip"

          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$UPLOAD_ZIP"

          SUBMIT_JSON=""

          if [[ "$MODE" == "api_key" ]]; then
            SUBMIT_JSON="$(xcrun notarytool submit "$UPLOAD_ZIP" \
              --key "$KEY_PATH" \
              --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
              --issuer "$APPLE_NOTARYTOOL_ISSUER_ID" \
              --wait \
              --output-format json)"
          else
            SUBMIT_JSON="$(xcrun notarytool submit "$UPLOAD_ZIP" \
              --apple-id "$APPLE_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --wait \
              --output-format json)"
          fi

          echo "$SUBMIT_JSON"

          SUBMISSION_ID="$(python3 -c 'import json,sys; data=json.loads(sys.argv[1]); print(data.get("id", ""))' "$SUBMIT_JSON")"
          SUBMISSION_STATUS="$(python3 -c 'import json,sys; data=json.loads(sys.argv[1]); print(data.get("status", ""))' "$SUBMIT_JSON")"

          if [[ -z "$SUBMISSION_ID" ]]; then
            echo "::error::Failed to parse notary submission ID"
            exit 1
          fi

          if [[ "$SUBMISSION_STATUS" != "Accepted" ]]; then
            echo "::error::Notary submission status is '$SUBMISSION_STATUS' (expected 'Accepted')."
            if [[ "$MODE" == "api_key" ]]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --key "$KEY_PATH" \
                --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
                --issuer "$APPLE_NOTARYTOOL_ISSUER_ID" \
                --output-format json || true
            else
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --output-format json || true
            fi
            exit 1
          fi

          xcrun stapler staple -v "$APP_PATH"

      - name: Package release zip
        shell: bash
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail

          mkdir -p out
          PACKAGE="${{ matrix.package_prefix }}-v${VERSION}-macos-${{ matrix.arch }}.zip"
          ditto -c -k --sequesterRsrc --keepParent "dist/${{ matrix.product_name }}.app" "out/$PACKAGE"
          ls -lah out

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-macos-${{ matrix.channel }}-${{ matrix.arch }}
          path: out/*
          if-no-files-found: error

  publish-release:
    needs:
      - prepare
      - build-macos
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download release artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-macos-*
          merge-multiple: true
          path: dist

      - name: Publish GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          TAG: ${{ needs.prepare.outputs.tag }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
        shell: bash
        run: |
          set -euo pipefail

          NOTES_FILE="$RUNNER_TEMP/release-notes.md"
          python3 scripts/release_notes_from_changelog.py --tag "$TAG" > "$NOTES_FILE"

          if gh release view "$TAG" --repo "$GH_REPO" >/dev/null 2>&1; then
            gh release edit "$TAG" --notes-file "$NOTES_FILE" --repo "$GH_REPO"
            gh release upload "$TAG" dist/* --clobber --repo "$GH_REPO"
            exit 0
          fi

          if [[ "$PRERELEASE" == "true" ]]; then
            gh release create "$TAG" dist/* --title "$TAG" --notes-file "$NOTES_FILE" --prerelease --repo "$GH_REPO"
          else
            gh release create "$TAG" dist/* --title "$TAG" --notes-file "$NOTES_FILE" --repo "$GH_REPO"
          fi

  update-sparkle-appcasts:
    needs:
      - prepare
      - publish-release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Update Sparkle appcast files
        env:
          GITHUB_TOKEN: ${{ github.token }}
          SPARKLE_PRIVATE_ED_KEY: ${{ secrets.SPARKLE_PRIVATE_ED_KEY }}
        run: |
          set -euo pipefail
          python3 -m pip install --quiet cryptography
          python3 scripts/release/update_sparkle_appcasts.py \
            --repo "${{ github.repository }}" \
            --output-dir appcasts \
            --github-token "$GITHUB_TOKEN" \
            --require-signatures

      - name: Commit and push appcast updates
        env:
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          set -euo pipefail

          if git diff --quiet -- appcasts; then
            echo "No Sparkle appcast changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add appcasts/*.xml
          git commit -m "chore: update Sparkle appcasts for ${TAG}"
          git push origin HEAD:main

  update-homebrew-tap:
    needs:
      - prepare
      - publish-release
    runs-on: ubuntu-latest
    steps:
      - name: Check Homebrew tap token
        id: tap
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        shell: bash
        run: |
          if [[ -n "${HOMEBREW_TAP_TOKEN:-}" ]]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "HOMEBREW_TAP_TOKEN not set; skipping tap update."
          fi

      - name: Checkout Dockter
        if: ${{ steps.tap.outputs.enabled == 'true' }}
        uses: actions/checkout@v4

      - name: Clone homebrew tap
        if: ${{ steps.tap.outputs.enabled == 'true' }}
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          git clone "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/apotenza92/homebrew-tap.git" /tmp/homebrew-tap

      - name: Update Dockter casks
        if: ${{ steps.tap.outputs.enabled == 'true' }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          python3 scripts/release/update_homebrew_tap_casks.py --tap-path /tmp/homebrew-tap --repo apotenza92/dockter

      - name: Commit and push tap updates
        if: ${{ steps.tap.outputs.enabled == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          cd /tmp/homebrew-tap

          if git diff --quiet -- Casks/dockter.rb Casks/dockter@beta.rb; then
            echo "No Homebrew cask changes to push."
            exit 0
          fi

          git config user.name "dockactioner-release-bot"
          git config user.email "actions@users.noreply.github.com"
          git add Casks/dockter.rb Casks/dockter@beta.rb
          git commit -m "Update Dockter casks from release metadata"
          git push origin main
